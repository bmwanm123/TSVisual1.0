1
00:00:14,250 --> 00:00:15,175
大家好 Hello everyone

2
00:00:15,525 --> 00:00:18,710
指针变量用于存放变量的地址

3
00:00:19,150 --> 00:00:22,360
同样我们可以定义一个指针变量

4
00:00:22,475 --> 00:00:25,225
用来指向一个结构体变量

5
00:00:25,500 --> 00:00:27,950
这时这个指针变量的值

6
00:00:27,950 --> 00:00:31,080
就是结构体变量的起始地址

7
00:00:31,725 --> 00:00:34,000
今天我们学习第三节 Today we will learn section 3

8
00:00:34,100 --> 00:00:36,295
指向结构体的指针 pointer to structure.

9
00:00:37,625 --> 00:00:38,770
在这一节

10
00:00:38,770 --> 00:00:41,040
给大家介绍三个问题

11
00:00:41,500 --> 00:00:45,520
如何定义指向结构体变量的指针变量

12
00:00:46,375 --> 00:00:48,315
使用结构体指针变量

13
00:00:48,315 --> 00:00:50,315
引用结构体的成员

14
00:00:50,315 --> 00:00:53,590
和访问结构体数组元素的成员

15
00:00:55,100 --> 00:00:58,470
与定义结构体变量的方法一样

16
00:00:58,800 --> 00:01:01,495
可以先定义结构体类型

17
00:01:01,750 --> 00:01:05,205
再定义指向结构体的指针变量

18
00:01:06,150 --> 00:01:09,350
也可以在定义结构体类型的同时

19
00:01:09,525 --> 00:01:12,570
定义指向结构体的指针变量

20
00:01:12,975 --> 00:01:14,865
这是常用格式

21
00:01:15,600 --> 00:01:17,910
先定义结构体类型

22
00:01:18,125 --> 00:01:21,475
再定义指向结构体的指针变量

23
00:01:21,925 --> 00:01:22,695
例如

24
00:01:23,325 --> 00:01:26,935
这里定义了一个student结构体类型

25
00:01:27,275 --> 00:01:29,105
同时定义了一个

26
00:01:29,105 --> 00:01:32,065
结构体类型的变量stu

27
00:01:32,650 --> 00:01:34,795
然后又定义了一个

28
00:01:34,825 --> 00:01:37,345
指向student结构体类型的

29
00:01:37,345 --> 00:01:39,060
指针变量p

30
00:01:39,900 --> 00:01:43,700
同时用变量stu的起始地址

31
00:01:43,800 --> 00:01:45,760
对p进行初始化

32
00:01:46,425 --> 00:01:47,430
也就是说

33
00:01:47,550 --> 00:01:51,755
p现在是指向结构体变量stu的

34
00:01:52,625 --> 00:01:53,735
如图所示

35
00:01:55,025 --> 00:01:58,775
结构体变量stu包含三个成员

36
00:01:59,475 --> 00:02:03,350
系统要为它分配一定大小的内存空间

37
00:02:04,475 --> 00:02:06,015
p就指向这个

38
00:02:06,025 --> 00:02:08,810
内存空间的起始地址

39
00:02:10,175 --> 00:02:13,315
定义了指向结构体变量的指针p

40
00:02:13,525 --> 00:02:14,645
那我们就

41
00:02:14,645 --> 00:02:16,775
可以利用这个指针变量p

42
00:02:16,850 --> 00:02:17,910
来引用

43
00:02:17,925 --> 00:02:19,290
它所指向的

44
00:02:19,290 --> 00:02:22,730
结构体变量stu的成员了

45
00:02:24,800 --> 00:02:27,370
这是第一种引用形式

46
00:02:28,400 --> 00:02:31,640
我们可以通过这种形式来引用

47
00:02:31,750 --> 00:02:35,670
结构体指针所指向的变量的成员

48
00:02:36,400 --> 00:02:37,150
例如

49
00:02:38,075 --> 00:02:39,225
先定义一个

50
00:02:39,225 --> 00:02:42,595
student结构体类型的变量stu

51
00:02:43,425 --> 00:02:44,745
再定义一个

52
00:02:44,745 --> 00:02:48,285
指向结构体类型的指针变量p

53
00:02:48,950 --> 00:02:52,750
同时把stu的地址赋给p

54
00:02:54,000 --> 00:02:57,485
如果现在要引用stu的成员

55
00:02:57,875 --> 00:02:59,820
当然可以直接通过

56
00:02:59,820 --> 00:03:02,300
变量名stu来访问

57
00:03:02,925 --> 00:03:03,680
这里

58
00:03:03,825 --> 00:03:08,485
是把101赋给stu的num成员

59
00:03:09,475 --> 00:03:11,115
我们也可以通过

60
00:03:11,115 --> 00:03:13,660
指向stu的指针p

61
00:03:13,775 --> 00:03:17,150
来访问stu里面的成员

62
00:03:17,850 --> 00:03:20,585
这里星p就代表

63
00:03:20,700 --> 00:03:22,775
p所指向的对象

64
00:03:22,950 --> 00:03:25,980
也就是stu结构体变量

65
00:03:28,275 --> 00:03:30,610
利用结构体指针变量

66
00:03:30,650 --> 00:03:32,525
引用结构体的成员

67
00:03:32,525 --> 00:03:34,410
还有第二种形式

68
00:03:34,825 --> 00:03:37,730
就是利用指向运算符

69
00:03:38,700 --> 00:03:40,700
通过指向运算符

70
00:03:40,700 --> 00:03:44,105
引用这个结构体指针所指向的

71
00:03:44,175 --> 00:03:46,375
那个变量的成员

72
00:03:47,250 --> 00:03:49,715
给stu的num成员

73
00:03:49,800 --> 00:03:52,865
赋值我们也可以写成这样

74
00:03:53,675 --> 00:03:56,300
将101赋给p

75
00:03:56,300 --> 00:04:00,245
所指向的变量stu的成员num

76
00:04:01,350 --> 00:04:04,675
这两种利用结构体指针变量

77
00:04:04,675 --> 00:04:07,540
来引用结构体成员的形式

78
00:04:07,625 --> 00:04:08,995
都是可以的

79
00:04:09,825 --> 00:04:13,200
效果与直接通过结构体变量名

80
00:04:13,300 --> 00:04:15,630
来引用成员是一样的

81
00:04:18,400 --> 00:04:20,620
下面我们再看一个例子

82
00:04:20,775 --> 00:04:22,490
这个例子说明了

83
00:04:22,490 --> 00:04:25,595
结构体成员的三种引用方法

84
00:04:25,725 --> 00:04:28,920
首先定义了一个结构体类型

85
00:04:29,375 --> 00:04:31,120
用typedef语句

86
00:04:31,175 --> 00:04:34,330
给结构体类型取了一个类型名

87
00:04:34,600 --> 00:04:36,400
大写的student

88
00:04:37,400 --> 00:04:38,925
在主函数中

89
00:04:39,050 --> 00:04:42,475
定义student结构体变量stu

90
00:04:42,475 --> 00:04:45,635
和结构体指针变量q 

91
00:04:46,475 --> 00:04:49,495
把stu的地址赋给q 

92
00:04:50,100 --> 00:04:53,150
q现在指向stu了

93
00:04:54,200 --> 00:04:56,265
通过成员运算符

94
00:04:56,275 --> 00:05:00,895
给stu结构体变量的三个成员赋值

95
00:05:02,850 --> 00:05:04,780
用我们前面讲的

96
00:05:04,850 --> 00:05:06,975
三种成员引用方法

97
00:05:07,125 --> 00:05:08,725
依次输出

98
00:05:08,725 --> 00:05:12,895
结构体变量stu的三个成员的值

99
00:05:14,825 --> 00:05:15,965
运行程序

100
00:05:16,925 --> 00:05:18,860
从结果中看出

101
00:05:19,075 --> 00:05:23,035
这三种引用方法是完全相同的

102
00:05:24,425 --> 00:05:25,060
下面

103
00:05:25,150 --> 00:05:27,990
再看一个结构体指针变量

104
00:05:27,990 --> 00:05:30,335
作函数参数的例子

105
00:05:31,625 --> 00:05:35,860
这个程序是用结构体指针变量zp

106
00:05:35,860 --> 00:05:38,575
做函数sub的形参

107
00:05:39,225 --> 00:05:40,790
在主函数中

108
00:05:40,790 --> 00:05:42,790
调用sub函数时

109
00:05:43,050 --> 00:05:44,660
传给形参的

110
00:05:44,660 --> 00:05:48,095
就要是一个结构体变量的地址

111
00:05:48,675 --> 00:05:49,300
这里

112
00:05:49,300 --> 00:05:52,590
传的是结构体变量a的地址

113
00:05:53,100 --> 00:05:57,220
相当于把a的地址传给了zp

114
00:05:57,525 --> 00:06:01,045
指针zp就指向变量a了

115
00:06:02,050 --> 00:06:03,775
在sub函数中

116
00:06:03,975 --> 00:06:05,295
首先输出

117
00:06:05,475 --> 00:06:09,475
zp所指结构体变量的x y成员

118
00:06:09,750 --> 00:06:11,200
也就是输出

119
00:06:11,350 --> 00:06:15,905
结构体变量a的x成员和y成员

120
00:06:16,375 --> 00:06:20,270
结果为负10和负20.5

121
00:06:21,025 --> 00:06:23,545
然后通过指向运算符

122
00:06:23,675 --> 00:06:26,705
修改zp所指向的变量

123
00:06:26,800 --> 00:06:29,450
a中的成员x和y

124
00:06:30,175 --> 00:06:32,500
所以返回主函数后

125
00:06:32,800 --> 00:06:35,180
变量a中的两个成员

126
00:06:35,350 --> 00:06:36,975
已经被更新了

127
00:06:37,475 --> 00:06:40,660
输出a的x成员为50

128
00:06:40,900 --> 00:06:43,480
y成员为100.5

129
00:06:44,525 --> 00:06:45,715
运行程序

130
00:06:46,925 --> 00:06:49,750
结果和我们的分析一致

131
00:06:51,175 --> 00:06:54,500
结构体指针变量作函数参数时

132
00:06:54,850 --> 00:06:56,275
实参和形参

133
00:06:56,375 --> 00:06:59,295
是共享同一片内存空间的

134
00:07:00,150 --> 00:07:02,350
函数内形参的变化

135
00:07:02,350 --> 00:07:04,200
会影响实参

136
00:07:04,625 --> 00:07:06,850
是一种双向传递

137
00:07:08,300 --> 00:07:10,480
一个结构体指针变量

138
00:07:10,625 --> 00:07:14,155
还可以指向一个结构体数组元素

139
00:07:14,750 --> 00:07:15,575
也就是

140
00:07:15,575 --> 00:07:18,100
将结构体数组元素的地址

141
00:07:18,375 --> 00:07:21,575
赋给指向结构体的指针变量

142
00:07:22,575 --> 00:07:23,395
例如

143
00:07:24,125 --> 00:07:28,340
这里定义了一个结构体数组arr

144
00:07:28,825 --> 00:07:30,255
包含3个元素

145
00:07:30,650 --> 00:07:31,370
同时

146
00:07:31,425 --> 00:07:32,525
定义了一个

147
00:07:32,525 --> 00:07:36,000
指向这个结构体的指针变量p

148
00:07:36,900 --> 00:07:40,415
然后把数组arr的首地址

149
00:07:40,575 --> 00:07:41,610
赋给p

150
00:07:43,025 --> 00:07:44,065
这条语句

151
00:07:44,775 --> 00:07:46,070
就等价于

152
00:07:46,400 --> 00:07:47,535
这一条语句

153
00:07:48,925 --> 00:07:49,590
此时

154
00:07:49,950 --> 00:07:54,600
p就指向arr数组的第一个元素了

155
00:07:55,875 --> 00:07:58,500
如果现在执行p加加

156
00:07:59,300 --> 00:07:59,970
那么

157
00:08:00,200 --> 00:08:04,600
指针变量p就指向数组arr中的

158
00:08:04,825 --> 00:08:06,440
第二个元素了

159
00:08:08,125 --> 00:08:10,565
从图中我们可以看出

160
00:08:10,700 --> 00:08:13,210
指针的这种指向关系

161
00:08:14,275 --> 00:08:16,800
这种指向关系一旦建立

162
00:08:17,200 --> 00:08:18,720
我们就可以使用

163
00:08:18,800 --> 00:08:20,905
结构体指针变量p

164
00:08:21,200 --> 00:08:25,120
来访问结构体数组元素的成员了

165
00:08:25,950 --> 00:08:26,500
下面

166
00:08:26,550 --> 00:08:27,510
看一个例子

167
00:08:30,125 --> 00:08:33,840
程序定义了一个结构体数组arr

168
00:08:34,075 --> 00:08:37,755
和一个指向结构体的指针变量p

169
00:08:38,775 --> 00:08:39,515
并且

170
00:08:39,550 --> 00:08:43,790
让p指向arr数组的第一个元素 

171
00:08:45,050 --> 00:08:45,940
接下来

172
00:08:46,075 --> 00:08:48,450
输出p所指向的

173
00:08:48,625 --> 00:08:52,025
数组元素的a成员和b成员

174
00:08:52,800 --> 00:08:56,040
结果分别是10和20.5

175
00:08:57,500 --> 00:08:58,415
再下来

176
00:08:58,575 --> 00:09:00,515
是移动指针p

177
00:09:01,325 --> 00:09:03,375
指针移动一个单位后

178
00:09:03,700 --> 00:09:06,670
指向arr的第二个元素

179
00:09:07,825 --> 00:09:10,215
再输出p所指向的

180
00:09:10,350 --> 00:09:12,205
数组元素的成员

181
00:09:12,525 --> 00:09:15,245
也就是输出arr

182
00:09:15,350 --> 00:09:20,000
第二个数组元素的a成员和b成员

183
00:09:20,875 --> 00:09:24,775
结果分别是30和40.5

184
00:09:25,725 --> 00:09:26,890
运行程序

185
00:09:27,700 --> 00:09:28,820
得到结果

186
00:09:32,250 --> 00:09:32,875
下面

187
00:09:33,000 --> 00:09:34,210
再看一个例子

188
00:09:35,475 --> 00:09:37,350
程序中的sub函数

189
00:09:37,600 --> 00:09:41,280
是用结构体数组z作形参

190
00:09:42,300 --> 00:09:43,960
在主函数中

191
00:09:43,975 --> 00:09:47,225
定义的是一个结构体数组a

192
00:09:48,025 --> 00:09:50,025
并且给数组a中的

193
00:09:50,025 --> 00:09:52,755
两个元素的成员x和y

194
00:09:52,755 --> 00:09:54,475
都赋了初值

195
00:09:55,575 --> 00:09:56,655
定义了一个

196
00:09:56,775 --> 00:10:00,575
指向结构体的指针变量sp

197
00:10:01,425 --> 00:10:05,905
并且把数组a的首地址赋给了sp

198
00:10:06,575 --> 00:10:07,220
所以

199
00:10:07,275 --> 00:10:10,970
现在指针sp是指向数组a的

200
00:10:10,970 --> 00:10:12,590
第一个元素的

201
00:10:14,225 --> 00:10:17,175
主函数中调用sub函数时

202
00:10:17,400 --> 00:10:21,630
是用指针变量sp作为实参

203
00:10:22,275 --> 00:10:26,080
把sp的值传给了形参z

204
00:10:26,725 --> 00:10:29,875
也就是把数组a的首地址

205
00:10:30,025 --> 00:10:32,855
传给了形参数组z

206
00:10:33,275 --> 00:10:36,750
那么实参数组a和形参数组z

207
00:10:36,900 --> 00:10:39,710
就共享同一片内存空间

208
00:10:40,475 --> 00:10:42,225
在sub函数中

209
00:10:42,275 --> 00:10:44,870
先输出形参数组z的

210
00:10:45,050 --> 00:10:48,400
第一个元素的两个成员x和y 

211
00:10:48,675 --> 00:10:52,875
分别为负10和负20.5

212
00:10:53,250 --> 00:10:56,325
然后修改形参数组z的

213
00:10:56,450 --> 00:10:59,930
第一个元素的两个成员x和y

214
00:11:01,025 --> 00:11:04,600
实际上就是修改实参数组a

215
00:11:04,600 --> 00:11:08,265
第一个元素的两个成员x和y

216
00:11:08,850 --> 00:11:10,970
所以返回主函数后

217
00:11:11,050 --> 00:11:14,175
数组a的第一个元素的两个成员

218
00:11:14,175 --> 00:11:15,935
已经被更新了

219
00:11:17,500 --> 00:11:19,440
通过指针sp

220
00:11:19,440 --> 00:11:23,205
输出数组a第一个元素的两个成员

221
00:11:23,975 --> 00:11:27,485
结果变为50和100.5

222
00:11:28,200 --> 00:11:29,430
运行程序

223
00:11:30,525 --> 00:11:31,740
得到结果

224
00:11:35,275 --> 00:11:37,965
现在请大家再想一想

225
00:11:38,675 --> 00:11:41,515
如果在调用sub函数时

226
00:11:41,800 --> 00:11:44,710
实参是加加sp

227
00:11:45,300 --> 00:11:47,395
那么结果会怎样呢

228
00:11:49,100 --> 00:11:52,850
加加sp是前缀自增运算

229
00:11:53,575 --> 00:11:55,355
sp先加1

230
00:11:55,600 --> 00:11:59,295
再使用sp的值作为实参

231
00:12:00,525 --> 00:12:02,170
sp加1后

232
00:12:02,475 --> 00:12:04,300
指针sp的值

233
00:12:04,300 --> 00:12:08,080
是数组a第二个元素的首地址

234
00:12:08,675 --> 00:12:09,635
也就是

235
00:12:09,675 --> 00:12:13,820
sp是指向数组a的第二个元素

236
00:12:14,775 --> 00:12:15,785
同时

237
00:12:15,850 --> 00:12:19,400
加加sp的值也是数组a

238
00:12:19,400 --> 00:12:21,920
第二个元素的首地址

239
00:12:23,100 --> 00:12:26,340
如果用加加sp作实参

240
00:12:26,625 --> 00:12:27,370
那么

241
00:12:27,425 --> 00:12:29,125
是把数组a的

242
00:12:29,175 --> 00:12:31,270
第二个元素的首地址

243
00:12:31,350 --> 00:12:34,950
传给了函数形参数组z

244
00:12:35,900 --> 00:12:36,625
所以

245
00:12:36,650 --> 00:12:38,075
在sub函数中

246
00:12:38,075 --> 00:12:39,975
输出形参数组z的

247
00:12:40,025 --> 00:12:43,370
第一个元素的两个成员x和y 

248
00:12:43,575 --> 00:12:46,580
实际上是输出数组a的

249
00:12:46,600 --> 00:12:48,860
第二个元素的两个成员

250
00:12:49,275 --> 00:12:52,085
分别为10和20.5

251
00:12:52,625 --> 00:12:53,445
然后

252
00:12:53,475 --> 00:12:55,575
修改形参数组z的

253
00:12:55,675 --> 00:12:58,730
第一个元素的两个成员x和y

254
00:12:59,050 --> 00:12:59,820
实际上

255
00:12:59,950 --> 00:13:02,425
就是修改实参数组a

256
00:13:02,500 --> 00:13:06,215
第二个元素的两个成员x和y

257
00:13:07,100 --> 00:13:09,435
所以返回主函数后

258
00:13:09,725 --> 00:13:13,075
数组a的第二个元素的两个成员

259
00:13:13,275 --> 00:13:15,085
已经被更新了

260
00:13:15,925 --> 00:13:17,670
而指针sp

261
00:13:17,825 --> 00:13:20,890
是指向数组a的第二个元素的

262
00:13:21,975 --> 00:13:25,975
输出sp指针指向的结构体成员

263
00:13:26,125 --> 00:13:27,300
就是输出

264
00:13:27,450 --> 00:13:30,770
数组a第二个元素的两个成员

265
00:13:31,550 --> 00:13:34,865
结果变为50和100.5

266
00:13:35,650 --> 00:13:37,410
这是运行结果

267
00:13:39,700 --> 00:13:41,395
我们再想一想

268
00:13:42,300 --> 00:13:44,485
如果调用sub函数时

269
00:13:44,775 --> 00:13:47,485
实参为sp加加

270
00:13:47,975 --> 00:13:50,165
结果又会怎样呢

271
00:13:51,875 --> 00:13:55,705
sp加加是后缀自增运算

272
00:13:56,800 --> 00:13:58,350
执行完这个运算

273
00:13:58,825 --> 00:14:00,735
指针sp的值

274
00:14:00,925 --> 00:14:04,670
是数组a第二个元素的首地址

275
00:14:05,475 --> 00:14:06,325
但是

276
00:14:06,425 --> 00:14:08,250
sp加加的值

277
00:14:08,300 --> 00:14:10,470
仍然是数组a

278
00:14:10,470 --> 00:14:13,240
第一个元素的首地址

279
00:14:14,125 --> 00:14:17,440
如果用sp加加作实参

280
00:14:17,850 --> 00:14:18,685
那么

281
00:14:18,685 --> 00:14:22,080
是把数组a的第一个元素的首地址

282
00:14:22,150 --> 00:14:25,175
传给了函数形参数组z

283
00:14:25,975 --> 00:14:26,725
所以

284
00:14:26,925 --> 00:14:28,520
在sub函数中

285
00:14:28,520 --> 00:14:30,170
输出结果为

286
00:14:30,170 --> 00:14:32,805
负10和负20.5

287
00:14:33,675 --> 00:14:35,165
在主函数中

288
00:14:35,325 --> 00:14:37,185
输出指针sp

289
00:14:37,275 --> 00:14:39,435
所指结构体的成员

290
00:14:39,525 --> 00:14:42,390
也就是输出数组a的

291
00:14:42,400 --> 00:14:44,590
第二个元素的成员

292
00:14:45,350 --> 00:14:47,025
它们没有被修改

293
00:14:47,325 --> 00:14:51,390
结果仍然为10和20.5

294
00:14:51,775 --> 00:14:54,025
这是运行结果

295
00:14:59,350 --> 00:15:02,270
今天这节课我们给大家介绍了

296
00:15:02,270 --> 00:15:04,385
指向结构体的指针

297
00:15:05,025 --> 00:15:07,170
可以定义一个指针变量

298
00:15:07,170 --> 00:15:09,320
来指向一个结构体变量

299
00:15:09,320 --> 00:15:11,720
或结构体数组元素

300
00:15:12,125 --> 00:15:15,005
这就是结构体指针变量

301
00:15:15,575 --> 00:15:18,775
这个指针变量的值是结构体变量

302
00:15:18,775 --> 00:15:21,600
或结构体数组元素的地址

303
00:15:22,275 --> 00:15:24,390
这样我们就可以通过

304
00:15:24,390 --> 00:15:26,500
指向结构体变量的指针

305
00:15:26,500 --> 00:15:28,725
来访问结构体变量

306
00:15:28,725 --> 00:15:31,590
或结构体数组元素的成员了

307
00:15:32,600 --> 00:15:34,590
访问形式有两种

308
00:15:34,975 --> 00:15:36,275
这两种形式

309
00:15:36,300 --> 00:15:39,935
都等价于直接通过结构体变量名

310
00:15:39,975 --> 00:15:42,070
或结构体数组元素

311
00:15:42,070 --> 00:15:44,200
来访问结构体成员

312
00:15:44,950 --> 00:15:47,390
好了 今天的课就到这

313
00:15:47,390 --> 00:15:48,370
谢谢大家

314
00:15:48,450 --> 00:15:50,605
我们下次课再见

